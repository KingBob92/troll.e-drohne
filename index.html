<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<title>TROLL.e – Drohnen-Andocken (Voices mit Prioritäten)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html,body{margin:0;background:#0b0e18;color:#e8f0ff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
  #stageWrap{position:fixed;inset:0;display:grid;place-items:center}
  #stage{position:relative;width:1536px;height:1024px}
  canvas{display:block;width:100%;height:100%}
  .overlay{position:absolute;left:0;right:0;pointer-events:none}
  #uiTop{top:12px;display:flex;justify-content:space-between;gap:12px;padding:0 16px;align-items:center}
  .stack{display:flex;gap:12px;align-items:center}
  .chip{pointer-events:auto;padding:6px 10px;background:#151a2c;border:1px solid #2a3355;border-radius:8px}
  .bar{position:relative;width:260px;height:14px;background:#1a2140;border:1px solid #2a3355;border-radius:8px;overflow:hidden}
  .bar>span{position:absolute;left:0;top:0;bottom:0;width:100%;background:#6bffb0}
  #subtitle{bottom:12px;text-align:center;padding:6px 10px;margin:0 16px;background:#101424;border:1px solid #28304e;border-radius:8px;min-height:2.2em}
  #start,#end{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  #end{display:none}
  .panel{pointer-events:auto;background:#0f1322cc;border:1px solid #2a3355;border-radius:12px;padding:18px 20px;text-align:center;box-shadow:0 4px 24px #0008}
  button{appearance:none;border:1px solid #2a3355;background:#161b30;color:#e8f0ff;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
  button:hover{filter:brightness(1.07)}
</style>
</head>
<body>
<div id="stageWrap">
  <div id="stage">
    <canvas id="game" width="1536" height="1024"></canvas>

    <div id="uiTop" class="overlay">
      <div class="stack">
        <div class="chip">Zeit: <span id="time">02:00</span></div>
        <div class="chip">Ziel: <span id="goal">Anker finden → Andocken</span></div>
      </div>
      <div class="stack">
        <div class="chip">Health: <span id="hpText">100%</span></div>
        <div class="bar"><span id="hpBar"></span></div>
      </div>
    </div>

    <div id="subtitle" class="overlay"></div>

    <div id="start">
      <div class="panel">
        <h2>Drohneneinsatz – Andockmanöver</h2>
        <p>WASD/←↑→↓ bewegen, <b>Shift</b> Boost, <b>E</b> Dock-Versuch. Wände & Treffer: nur Health-Schaden.</p>
        <button id="btnStart">Start</button>
      </div>
    </div>

    <div id="end">
      <div class="panel">
        <h2 id="endTitle">Ende</h2>
        <p id="endMsg"></p>
        <button id="btnRetry">Nochmal</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== Größen / Fit-to-window ===== */
const VIEW_W=1536, VIEW_H=1024, BG_W=2350, BG_H=1024;
function fit(){const vw=innerWidth,vh=innerHeight,rat=VIEW_W/VIEW_H;let w=vw,h=w/rat;if(h>vh){h=vh;w=h*rat}const s=document.getElementById('stage');s.style.width=w+'px';s.style.height=h+'px'}
addEventListener('resize',fit);fit();

/* ===== Canvas/DOM ===== */
const cvs=document.getElementById('game'), ctx=cvs.getContext('2d');
const uiTime=document.getElementById('time'), uiGoal=document.getElementById('goal'), uiSub=document.getElementById('subtitle');
const hpText=document.getElementById('hpText'), hpBar=document.getElementById('hpBar');
document.getElementById('btnStart').onclick=onStart; document.getElementById('btnRetry').onclick=()=>location.reload();

/* ===== Input ===== */
const keys={}; addEventListener('keydown',e=>{keys[e.key.toLowerCase()]=true}); addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false});
addEventListener('keydown',e=>{if(e.key.toLowerCase()==='e')tryDock()});

/* ===== Assets (Grafik) ===== */
function img(src){const i=new Image(); i.src=src; return i;}
const bgLayers=[
  {img:img('Assets/BACK/BACK_ebene_6.png'), depth:0.0},
  {img:img('Assets/BACK/BACK_ebene_5.png'), depth:0.2},
  {img:img('Assets/BACK/BACK_ebene_4.png'), depth:0.4},
  {img:img('Assets/BACK/BACK_ebene_3.png'), depth:0.6},
  {img:img('Assets/BACK/BACK_ebene_2.png'), depth:0.8},
  {img:img('Assets/BACK/BACK_ebene_1.png'), depth:1.0}
];
const overlay=img('Assets/MAIN_OVERLAY.png');
const drOff=img('Assets/DROHNE/DROHNE_off.png'), drOn=img('Assets/DROHNE/DROHNE_on.png'), drBoost=img('Assets/DROHNE/DROHNE_boost.png');

/* ===== Props (Sprites) ===== */
const SPRITES = {
  asteroid: [ img('Assets/PROPS/Asteroid_1.png'), img('Assets/PROPS/Asteroid_2.png'), img('Assets/PROPS/Asteroid_3.png') ],
  stone:    [ img('Assets/PROPS/Stone_1.png'),    img('Assets/PROPS/Stone_2.png'),    img('Assets/PROPS/Stone_3.png') ],
  trash:    [ img('Assets/PROPS/Trash_1.png'),    img('Assets/PROPS/Trash_2.png'),    img('Assets/PROPS/Trash_3.png'),
              img('Assets/PROPS/Trash_4.png'),    img('Assets/PROPS/Trash_5.png') ]
};

/* ===== SFX / Musik ===== */
class SFX {
  constructor(map){ this.map=new Map(); for(const [k,url] of Object.entries(map)){ const a=new Audio(url); a.preload='auto'; this.map.set(k,a);} }
  play(key,{volume=1.0, loop=false}={}){ const src=this.map.get(key); if(!src) return;
    const a=src.cloneNode(true); a.volume=volume; a.loop=loop; a.play().catch(()=>{}); return a;
  }
  stop(node){ try{ node.pause(); node.currentTime=0; }catch(_){}}}
const sfx = new SFX({
  start:  'Assets/SOUND/SFX/DROHNE_start.mp3',
  hit1:   'Assets/SOUND/SFX/DROHNE_demage_1.mp3',
  hit2:   'Assets/SOUND/SFX/DROHNE_demage_2.mp3',
  max1:   'Assets/SOUND/SFX/DROHNE_demage_max_1.mp3',
  max2:   'Assets/SOUND/SFX/DROHNE_demage_max_2.mp3',
  max3:   'Assets/SOUND/SFX/DROHNE_demage_max_3.mp3',
  count:  'Assets/SOUND/SFX/ANKER_count.mp3',
  dockok: 'Assets/SOUND/SFX/DOCKING_correct.mp3'
});
const music = new Audio('Assets/SOUND/Music.mp3'); music.loop = true; music.volume = 0.25;

/* ===== VOICE-ENGINE (keine Überlappung, Prioritäten) ===== */
const VOICE_PRI = { dialog:1, start:2, demage:3, end10:4, end:5 };
const voiceClips = {
  start:  new Audio('Assets/SOUND/VOICES/VOICE_start.mp3'),
  end10:  new Audio('Assets/SOUND/VOICES/VOICE_end_10.mp3'),
  end:    new Audio('Assets/SOUND/VOICES/VOICE_end.mp3'),
  demage1:new Audio('Assets/SOUND/VOICES/VOICE_demage_1.mp3'),
  demage2:new Audio('Assets/SOUND/VOICES/VOICE_demage_2.mp3'),
  demage3:new Audio('Assets/SOUND/VOICES/VOICE_demage_3.mp3'),
  // Dialog 1..8 werden dynamisch über Funktion geladen
};
for (const k in voiceClips){ voiceClips[k].preload='auto'; voiceClips[k].volume=0.95; }

function makeDialog(n){ const a=new Audio(`Assets/SOUND/VOICES/VOICE_dialog_${n}.mp3`); a.preload='auto'; a.volume=0.95; return a; }
const dialogBank = Array.from({length:8},(_,i)=>makeDialog(i+1));

const Voice = {
  cur:null, pri:0, endTimer:null, dialogTimer:null,
  endPlayed:false, end10Played:false,
  stop(){
    if(this.cur){ try{ this.cur.onended=null; this.cur.pause(); this.cur.currentTime=0; }catch(_){ } this.cur=null; this.pri=0; }
  },
  play(audio, pri, {scheduleNextDialog=true}={}){
    if(!audio) return;
    if(this.cur && pri < this.pri){ return; } // niedriger – ignoriere
    // höher oder gleich: abbrechen & neu
    if(this.cur){ this.stop(); }
    this.pri = pri;
    this.cur = audio.cloneNode(true);
    this.cur.volume = audio.volume ?? 0.95;
    this.cur.onended = () => {
      this.cur = null; this.pri = 0;
      if (!this.endPlayed && scheduleNextDialog){
        clearTimeout(this.dialogTimer);
        this.dialogTimer = setTimeout(()=> Voice.playRandomDialog(), 3000);
      }
    };
    this.cur.play().catch(()=>{});
  },
  playKey(key, pri, opts){ const a = voiceClips[key]; this.play(a, pri, opts); },
  playRandomDialog(){
    if (this.endPlayed) return;
    const a = dialogBank[Math.floor(Math.random()*dialogBank.length)];
    this.play(a, VOICE_PRI.dialog);
  }
};

/* ===== Game-Config ===== */
const CFG={TIME_LIMIT:120,LOW_WARN:20,DOCK_HOLD:3.0,
           BOOST_FACTOR:1.6,BOOST_TIME:0.5,BOOST_COOLDOWN:2.0};
let gameRunning=false, firstCollision=false, timeLeft=CFG.TIME_LIMIT;

/* ===== Health ===== */
let health = 100;
function applyDamage(amount){
  const prev = health;
  health = Math.max(0, health - amount);
  updateHealthUI();

  // Voice-Demage bei Schwellen (unterbricht geringere Voices)
  if (prev >= 15 && health < 15){ Voice.playKey('demage3', VOICE_PRI.demage); sfx.play('max3'); }
  else if (prev >= 50 && health < 50){ Voice.playKey('demage2', VOICE_PRI.demage); sfx.play('max2'); }
  else if (prev >= 80 && health < 80){ Voice.playKey('demage1', VOICE_PRI.demage); sfx.play('max1'); }
  else sfx.play(Math.random()<0.5?'hit1':'hit2');

  if (health <= 0){
    gameRunning=false; stopDockCount(); Voice.endPlayed = true; Voice.stop();
    uiGoal.textContent='Drohne zerstört – Abbruch';
    showEnd(false,'Drohne zerstört','Die Drohne hat zu viel Schaden erlitten.');
  }
}
function updateHealthUI(){
  hpText.textContent = `${health}%`;
  hpBar.style.width = `${Math.max(0, health)}%`;
  if (health > 60) hpBar.style.background = '#6bffb0';
  else if (health > 35) hpBar.style.background = '#ffd866';
  else hpBar.style.background = '#ff6b6b';
}

/* ===== Spielfeld & Zonen ===== */
const MARGIN_X = 28, MARGIN_TOP = 60, MARGIN_BOTTOM = 60;
const BOUNDS = { minX:MARGIN_X, maxX:VIEW_W-MARGIN_X, minY:MARGIN_TOP, maxY:VIEW_H-MARGIN_BOTTOM };
const START_W = 220; // Startzone links
const PROP_LEFT_WALL  = BOUNDS.minX + START_W; // Props tabu

/* ===== Drohne (mit „Eigenleben“) ===== */
const drone={x:BOUNDS.minX+20,y:(BOUNDS.minY+BOUNDS.maxY)/2,vx:0,vy:0,radius:24,boostLeft:0,boostCD:0};
const THRUST=340, MAX_SPD=220, DRAG=1.7;
let wallHitCD = 0;

const GREMLIN = { strength:250, targetX:0,targetY:0, curX:0,curY:0, t:0, changeEvery:1.0 };
function retargetGremlin(){ const ang=Math.random()*Math.PI*2, mag=0.6+Math.random()*0.9; GREMLIN.targetX=Math.cos(ang)*mag; GREMLIN.targetY=Math.sin(ang)*mag; GREMLIN.changeEvery=0.7+Math.random()*0.7; }
retargetGremlin();
function updateGremlin(dt){ GREMLIN.t+=dt; const f=1-Math.exp(-3.2*dt); GREMLIN.curX += (GREMLIN.targetX-GREMLIN.curX)*f; GREMLIN.curY += (GREMLIN.targetY-GREMLIN.curY)*f; if(GREMLIN.t>=GREMLIN.changeEvery){GREMLIN.t=0;retargetGremlin();}}

/* ===== Hindernisse ===== */
const obstacles=[];
const SPRITES2 = {
  asteroid: [ img('Assets/PROPS/Asteroid_1.png'), img('Assets/PROPS/Asteroid_2.png'), img('Assets/PROPS/Asteroid_3.png') ],
  stone:    [ img('Assets/PROPS/Stone_1.png'),    img('Assets/PROPS/Stone_2.png'),    img('Assets/PROPS/Stone_3.png') ],
  trash:    [ img('Assets/PROPS/Trash_1.png'),    img('Assets/PROPS/Trash_2.png'),    img('Assets/PROPS/Trash_3.png'), img('Assets/PROPS/Trash_4.png'), img('Assets/PROPS/Trash_5.png') ]
};
const rand = arr => arr[Math.floor(Math.random()*arr.length)];
function makeObstacle(cfg){
  const sprite = rand(SPRITES2[cfg.kind]); const ang=Math.random()*Math.PI*2, spd=cfg.speed??40, mass=cfg.mass??(cfg.big?2.0:1.0);
  let x=cfg.x,y=cfg.y;
  if (x==null){ do{x = BOUNDS.minX+START_W+10+Math.random()*((BOUNDS.maxX-10)-(BOUNDS.minX+START_W+10));} while(x < PROP_LEFT_WALL+10); }
  if (y==null){ y = BOUNDS.minY + 20 + Math.random() * (BOUNDS.maxY-BOUNDS.minY-40); }
  return { type:cfg.kind,big:!!cfg.big,dmg:cfg.dmg??(cfg.big?15:5), x,y, vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,
           r:cfg.r??24, angle:Math.random()*Math.PI*2, angVel:cfg.rot??0.8, sprite, mass };
}
function spawnObs(){
  obstacles.length=0;
  for(let i=0;i<5;i++) obstacles.push(makeObstacle({kind:'asteroid', big:true, dmg:15, r:38+Math.random()*10, speed:20+Math.random()*40, rot:(Math.random()*2-1)*0.6}));
  for(let i=0;i<8;i++) obstacles.push(makeObstacle({kind:'stone', big:false, dmg:5, r:20+Math.random()*8, speed:25+Math.random()*55, rot:(Math.random()*2-1)*1.0}));
  for(let i=0;i<12;i++) obstacles.push(makeObstacle({kind:'trash', big:false, dmg:5, r:15+Math.random()*6, speed:30+Math.random()*60, rot:(Math.random()*2-1)*1.4, mass:0.4}));
}

const OBJ_DRAG=0.02, WALL_BOUNCE=0.6, RESTITUTION=0.8;

/* ===== Anchor ===== */
const anchor={ baseX: BOUNDS.maxX-120, baseY:(BOUNDS.minY+BOUNDS.maxY)*0.45, rOuter:52,rInner:28, holdLeft:3.0, active:false, t:0,
               ampX:26,ampY:14, speedX:0.6,speedY:0.9, phase:Math.PI/4, x:0,y:0 };
anchor.x=anchor.baseX; anchor.y=anchor.baseY;
function updateAnchor(dt){ anchor.t+=dt; anchor.x=anchor.baseX+Math.cos(anchor.t*anchor.speedX+anchor.phase)*anchor.ampX; anchor.y=anchor.baseY+Math.sin(anchor.t*anchor.speedY)*anchor.ampY; }

let dockAttempt=false,inAnchor=false,dockSoundNode=null;
function tryDock(){
  if(!gameRunning) return;
  inAnchor=collideCircle(drone.x,drone.y,drone.radius,anchor.x,anchor.y,anchor.rInner);
  if(!inAnchor) return;
  dockAttempt=true; anchor.active=true; anchor.holdLeft=3.0;
  uiGoal.textContent='Andocken… Position halten';
  stopDockCount(); dockSoundNode = sfx.play('count');
}
function stopDockCount(){ if(dockSoundNode){ try{dockSoundNode.pause(); dockSoundNode.currentTime=0;}catch(_){ } dockSoundNode=null; } }
function updateDock(dt){
  inAnchor=collideCircle(drone.x,drone.y,drone.radius,anchor.x,anchor.y,anchor.rInner);
  if(!dockAttempt) return;
  if(!inAnchor){ dockAttempt=false; anchor.active=false; uiGoal.textContent='Andocken abgebrochen – Position halten & E drücken'; stopDockCount(); return; }
  anchor.holdLeft -= dt;
  if(anchor.holdLeft<=0){
    gameRunning=false; anchor.active=false; dockAttempt=false; stopDockCount();
    uiGoal.textContent='Andocken erfolgreich';
    say('Rohland','Andock-Signal grün. Na also.');
    sfx.play('dockok');
    Voice.endPlayed = true;
    Voice.playKey('end', VOICE_PRI.end, {scheduleNextDialog:false});
    showEnd(true,'Andocken erfolgreich','Die Wartungs-Drohne hat den Ankerpunkt erreicht.');
  }
}

/* ===== Parallax ===== */
const SCROLL_X_MAX=BG_W-VIEW_W, VSHIFT_MAX=60;
let mouseX=0,mouseY=0;
document.getElementById('stage').addEventListener('pointermove',e=>{
  const r=e.currentTarget.getBoundingClientRect();
  mouseX=((e.clientX-r.left)/r.width-0.5)*2; mouseY=((e.clientY-r.top)/r.height-0.5)*2;
});
document.getElementById('stage').addEventListener('pointerleave',()=>{mouseX=mouseY=0});
function drawParallax(){
  const nx=(drone.x-BOUNDS.minX)/(BOUNDS.maxX-BOUNDS.minX);
  const ny=(drone.y-BOUNDS.minY)/(BOUNDS.maxY-BOUNDS.minY);
  for(const L of bgLayers){
    let sx=Math.round((nx + mouseX*0.05) * SCROLL_X_MAX * L.depth);
    if(sx<0) sx=0; if(sx>SCROLL_X_MAX) sx=SCROLL_X_MAX;
    const vshift=Math.round(((ny-0.5) - mouseY*0.05) * VSHIFT_MAX * L.depth * -1);
    const destY=vshift;
    if(L.img.complete && L.img.naturalWidth){
      ctx.drawImage(L.img, sx, 0, VIEW_W, VIEW_H, 0, destY, VIEW_W, VIEW_H);
    } else { ctx.fillStyle='#05070e'; ctx.fillRect(0,0,VIEW_W,VIEW_H); }
  }
}

/* ===== Hilfen ===== */
function collideCircle(x1,y1,r1,x2,y2,r2){const dx=x2-x1,dy=y2-y1;return dx*dx+dy*dy <= (r1+r2)*(r1+r2)}

/* ===== Props: Update + Wände + Start-Zone + Kollisionen ===== */
function updateAndDrawObstacles(dt){
  for(const o of obstacles){
    o.vx -= o.vx * OBJ_DRAG * dt; o.vy -= o.vy * OBJ_DRAG * dt;
    o.x += o.vx * dt; o.y += o.vy * dt; o.angle += o.angVel * dt;
    if (o.x - o.r < BOUNDS.minX){ o.x = BOUNDS.minX + o.r; o.vx = Math.abs(o.vx)*WALL_BOUNCE; }
    if (o.x + o.r > BOUNDS.maxX){ o.x = BOUNDS.maxX - o.r; o.vx = -Math.abs(o.vx)*WALL_BOUNCE; }
    if (o.y - o.r < BOUNDS.minY){ o.y = BOUNDS.minY + o.r; o.vy = Math.abs(o.vy)*WALL_BOUNCE; }
    if (o.y + o.r > BOUNDS.maxY){ o.y = BOUNDS.maxY - o.r; o.vy = -Math.abs(o.vy)*WALL_BOUNCE; }
    if (o.x - o.r < PROP_LEFT_WALL){ o.x = PROP_LEFT_WALL + o.r; o.vx = Math.abs(o.vx)*WALL_BOUNCE; }
  }
  for(let i=0;i<obstacles.length;i++){
    const A=obstacles[i];
    for(let j=i+1;j<obstacles.length;j++){
      const B=obstacles[j];
      const dx=B.x-A.x, dy=B.y-A.y, rSum=A.r+B.r, d2=dx*dx+dy*dy;
      if (d2>0 && d2 < rSum*rSum){
        const d=Math.sqrt(d2)||1, nx=dx/d, ny=dy/d;
        const overlap=(rSum-d), mA=A.mass??1, mB=B.mass??1, massSum=mA+mB;
        const aPush=overlap*(mB/massSum), bPush=overlap*(mA/massSum);
        A.x -= nx*aPush; A.y -= ny*aPush; B.x += nx*bPush; B.y += ny*bPush;
        const relVx=B.vx-A.vx, relVy=B.vy-A.vy, sepVel=relVx*nx+relVy*ny;
        if(sepVel<0){ const j=-(1+RESTITUTION)*sepVel/(1/mA+1/mB), jx=j*nx, jy=j*ny; A.vx-=jx/mA; A.vy-=jy/mA; B.vx+=jx/mB; B.vy+=jy/mB; }
      }
    }
  }
  for(const o of obstacles){
    let fallback=(o.type==='asteroid')?'#9b6f5a':(o.type==='stone')?'#8aa0b5':'#b3b3b3';
    if (o.sprite && o.sprite.complete && o.sprite.naturalWidth){
      const size=o.r*2; ctx.save(); ctx.translate(o.x,o.y); ctx.rotate(o.angle);
      ctx.drawImage(o.sprite,-size/2,-size/2,size,size); ctx.restore();
    } else { ctx.fillStyle=fallback; ctx.beginPath(); ctx.arc(o.x,o.y,o.r,0,Math.PI*2); ctx.fill(); }
  }
}

/* ===== Drohne vs Props ===== */
function handleDroneCollisions(){
  for(const o of obstacles){
    if (!collideCircle(drone.x,drone.y,drone.radius, o.x,o.y,o.r)) continue;
    const nx=(drone.x-o.x), ny=(drone.y-o.y), d=Math.hypot(nx,ny)||1, ux=nx/d, uy=ny/d;
    const rel=(drone.vx-o.vx)*ux+(drone.vy-o.vy)*uy;
    const droMass=1.0, objMass=o.mass??(o.big?2.0:1.0), restitution=0.7;
    const j=-(1+restitution)*rel/(1/droMass+1/objMass);
    let droF=1.0, objF=1.0; if(o.type==='trash'){ droF=0.25; objF=1.2; }
    drone.vx += (j*ux/droMass)*droF; drone.vy += (j*uy/droMass)*droF;
    o.vx     -= (j*ux/objMass)*objF; o.vy     -= (j*uy/objMass)*objF;
    const overlap=(o.r+drone.radius)-d; if(overlap>0){ const push=overlap*0.7; drone.x+=ux*push; drone.y+=uy*push; if(o.type==='trash'){o.x-=ux*push*0.4; o.y-=uy*push*0.4;} }
    if(gameRunning){ applyDamage(o.dmg); }
    if(!firstCollision){ firstCollision=true; say('Rohland','Sanfter. Du fliegst das Ding wie ’n Presslufthammer.'); }
  }
}

/* ===== Anchor zeichnen ===== */
function drawAnchor(){
  const pulse=0.5+0.5*Math.sin(performance.now()/500);
  ctx.strokeStyle=`rgba(120,255,160,${0.5+0.3*pulse})`;
  ctx.lineWidth=6; ctx.beginPath(); ctx.arc(anchor.x,anchor.y,anchor.rOuter,0,Math.PI*2); ctx.stroke();
  ctx.lineWidth=3; ctx.beginPath(); ctx.arc(anchor.x,anchor.y,anchor.rInner*1.2,0,Math.PI*2); ctx.stroke();
  if(anchor.active){
    ctx.fillStyle='rgba(120,255,160,0.15)'; ctx.beginPath(); ctx.arc(anchor.x,anchor.y,anchor.rOuter,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#6bffb0'; ctx.font='600 18px system-ui,Segoe UI,Roboto,Arial'; ctx.textAlign='center';
    ctx.fillText(`Andocken… Position halten (${anchor.holdLeft.toFixed(1)} s)`, anchor.x, anchor.y-(anchor.rOuter+16));
  }
}

/* ===== Drohne + Wandschaden ===== */
function drawDrone(dt){
  updateGremlin(dt);
  if (wallHitCD>0) wallHitCD -= dt;

  let ix=0,iy=0;
  if(keys['a']||keys['arrowleft'])ix-=1;
  if(keys['d']||keys['arrowright'])ix+=1;
  if(keys['w']||keys['arrowup'])iy-=1;
  if(keys['s']||keys['arrowdown'])iy+=1;

  let accel=THRUST,maxSpd=MAX_SPD;
  if(drone.boostCD<=0 && (keys['shift']||keys['shiftleft']||keys['shiftright'])) drone.boostLeft=CFG.BOOST_TIME;
  if(drone.boostLeft>0){accel*=CFG.BOOST_FACTOR; maxSpd*=CFG.BOOST_FACTOR; drone.boostLeft-=dt; if(drone.boostLeft<=0){drone.boostLeft=0;drone.boostCD=CFG.BOOST_COOLDOWN}}
  else if(drone.boostCD>0){drone.boostCD-=dt}

  if(ix||iy){const l=Math.hypot(ix,iy)||1; ix/=l; iy/=l; drone.vx+=ix*accel*dt; drone.vy+=iy*accel*dt;}
  drone.vx += GREMLIN.curX * GREMLIN.strength * dt;
  drone.vy += GREMLIN.curY * GREMLIN.strength * dt;
  drone.vx-=drone.vx*Math.min(1,DRAG*dt);
  drone.vy-=drone.vy*Math.min(1,DRAG*dt);
  const sp=Math.hypot(drone.vx,drone.vy);
  if(sp>maxSpd){const s=maxSpd/sp; drone.vx*=s; drone.vy*=s;}

  drone.x+=drone.vx*dt; drone.y+=drone.vy*dt;

  let hitWall=false;
  if (drone.x < BOUNDS.minX){ drone.x = BOUNDS.minX; drone.vx = Math.abs(drone.vx)*0.6; hitWall=true; }
  if (drone.x > BOUNDS.maxX){ drone.x = BOUNDS.maxX; drone.vx = -Math.abs(drone.vx)*0.6; hitWall=true; }
  if (drone.y < BOUNDS.minY){ drone.y = BOUNDS.minY; drone.vy = Math.abs(drone.vy)*0.6; hitWall=true; }
  if (drone.y > BOUNDS.maxY){ drone.y = BOUNDS.maxY; drone.vy = -Math.abs(drone.vy)*0.6; hitWall=true; }
  if (gameRunning && hitWall && wallHitCD<=0){ applyDamage(5); wallHitCD=0.5; }

  let spr=drOff; if(drone.boostLeft>0 && drBoost.naturalWidth) spr=drBoost; else if(sp>40 && drOn.naturalWidth) spr=drOn;
  const size=64, half=size/2;
  if(spr.naturalWidth) ctx.drawImage(spr,Math.round(drone.x-half),Math.round(drone.y-half),size,size);
  else { ctx.fillStyle='#5078c8'; ctx.fillRect(drone.x-20,drone.y-14,40,28); }
}

/* ===== Overlay zuletzt ===== */
function drawOverlay(){ if(overlay.naturalWidth) ctx.drawImage(overlay,0,0,VIEW_W,VIEW_H); }

/* ===== Timer/Dialogs ===== */
function say(s,t){ uiSub.textContent=s?`[${s}] ${t}`:'' }
function fmt(t){const m=Math.floor(t/60),s=Math.floor(t%60);return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`}

/* ===== Loop ===== */
let last=performance.now()/1000;
function loop(){
  const now=performance.now()/1000, dt=Math.min(0.033,now-last); last=now;

  updateAnchor(dt);
  drawParallax();

  drawAnchor();
  updateAndDrawObstacles(dt);
  if (gameRunning) drawDrone(dt); else drawDrone(0);
  handleDroneCollisions();
  drawOverlay();

  if(gameRunning){
    timeLeft-=dt;

    // VOICE_end_10: einmalig bei <= 10s
    if (!Voice.end10Played && timeLeft<=10){
      Voice.end10Played = true;
      Voice.playKey('end10', VOICE_PRI.end10);
    }

    if(timeLeft<=0){
      timeLeft=0; gameRunning=false; say('Rüdiger','System hat abgebrochen… Mist.');
      uiGoal.textContent='Sicherheitsprotokoll aktiviert – Abbruch';
      stopDockCount();
      Voice.endPlayed = true; Voice.stop(); // keine weiteren Dialoge
      showEnd(false,'Zeit abgelaufen','Die Drohne hat es nicht rechtzeitig geschafft.');
    } else if(Math.ceil(timeLeft)===CFG.LOW_WARN){
      say('Rüdiger','Uff, uns rennt die Zeit weg!'); document.getElementById('time').style.color='#ff5c5c';
    }
    updateDock(dt);
  }
  uiTime.textContent=fmt(timeLeft);

  requestAnimationFrame(loop);
}
function showEnd(ok,title,msg){
  const e=document.getElementById('end');
  document.getElementById('endTitle').textContent=title;
  document.getElementById('endMsg').textContent=msg;
  e.style.display='flex';
}

/* ===== Start ===== */
function onStart(){
  timeLeft=CFG.TIME_LIMIT; gameRunning=true; firstCollision=false;
  document.getElementById('start').style.display='none';
  say('Rüdiger','Okay, ich übernehme die Steuerung… äh… glaube ich.');
  sfx.play('start', { volume: 1.0 });
  music.currentTime = 0; music.play().catch(()=>{});
  updateHealthUI();

  // VOICE_start nach 1.5s, dann Dialog-Schleife
  setTimeout(()=> {
    if (!gameRunning) return;
    Voice.playKey('start', VOICE_PRI.start);
  }, 1500);
  // Falls Start-Voice sehr kurz oder blockiert war, Dialoge automatisch anstoßen:
  clearTimeout(Voice.dialogTimer);
  Voice.dialogTimer = setTimeout(()=>Voice.playRandomDialog(), 4000);
}

/* ===== Init ===== */
function init(){ spawnObs(); loop(); } init();
</script>
</body>
</html>
